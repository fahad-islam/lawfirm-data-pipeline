// This file was generated by prisma-effect-generator, do not edit manually.

import { Cause, Context, Data, Effect, Exit, Option, Runtime } from "effect"
import { Service } from "effect/Effect"
import { Prisma, PrismaClient } from "./client.js"

export class PrismaClientService extends Context.Tag("PrismaClientService")<
  PrismaClientService,
  PrismaClient
>() {}

export class PrismaTransactionClientService extends Context.Tag("PrismaTransactionClientService")<
  PrismaTransactionClientService,
  Prisma.TransactionClient
>() {}

export class PrismaUniqueConstraintError extends Data.TaggedError("PrismaUniqueConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaForeignKeyConstraintError extends Data.TaggedError("PrismaForeignKeyConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRecordNotFoundError extends Data.TaggedError("PrismaRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelationViolationError extends Data.TaggedError("PrismaRelationViolationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaRelatedRecordNotFoundError extends Data.TaggedError("PrismaRelatedRecordNotFoundError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaTransactionConflictError extends Data.TaggedError("PrismaTransactionConflictError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueTooLongError extends Data.TaggedError("PrismaValueTooLongError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaValueOutOfRangeError extends Data.TaggedError("PrismaValueOutOfRangeError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaDbConstraintError extends Data.TaggedError("PrismaDbConstraintError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaConnectionError extends Data.TaggedError("PrismaConnectionError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaMissingRequiredValueError extends Data.TaggedError("PrismaMissingRequiredValueError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export class PrismaInputValidationError extends Data.TaggedError("PrismaInputValidationError")<{
  cause: Prisma.PrismaClientKnownRequestError
  operation: string
  model: string
}> {}

export type PrismaCreateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaDeleteError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

export type PrismaFindOrThrowError =
  | PrismaConnectionError
  | PrismaRecordNotFoundError

export type PrismaFindError =
  | PrismaConnectionError

export type PrismaDeleteManyError =
  | PrismaForeignKeyConstraintError
  | PrismaRelationViolationError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaUpdateManyError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaTransactionConflictError

export type PrismaError =
  | PrismaValueTooLongError
  | PrismaUniqueConstraintError
  | PrismaForeignKeyConstraintError
  | PrismaDbConstraintError
  | PrismaInputValidationError
  | PrismaMissingRequiredValueError
  | PrismaRelationViolationError
  | PrismaRelatedRecordNotFoundError
  | PrismaValueOutOfRangeError
  | PrismaConnectionError
  | PrismaRecordNotFoundError
  | PrismaTransactionConflictError

// Generic mapper for raw operations and fallback
const mapError = (error: unknown, operation: string, model: string): PrismaError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  // Unknown errors are not handled and will be treated as defects
  throw error;
}

// Specific mappers to narrow error types per operation

// Create, Upsert
const mapCreateError = (error: unknown, operation: string, model: string): PrismaCreateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Update
const mapUpdateError = (error: unknown, operation: string, model: string): PrismaUpdateError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2015":
      case "P2018":
        return new PrismaRelatedRecordNotFoundError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Delete
const mapDeleteError = (error: unknown, operation: string, model: string): PrismaDeleteError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// FindOrThrow
const mapFindOrThrowError = (error: unknown, operation: string, model: string): PrismaFindOrThrowError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2025":
        return new PrismaRecordNotFoundError({ cause: error, operation, model });
    }
  }
  throw error;
}

// Find
const mapFindError = (error: unknown, operation: string, model: string): PrismaFindError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
    }
  }
  throw error;
}

// DeleteMany
const mapDeleteManyError = (error: unknown, operation: string, model: string): PrismaDeleteManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2014":
        return new PrismaRelationViolationError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

// UpdateMany
const mapUpdateManyError = (error: unknown, operation: string, model: string): PrismaUpdateManyError => {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case "P2000":
        return new PrismaValueTooLongError({ cause: error, operation, model });
      case "P2002":
        return new PrismaUniqueConstraintError({ cause: error, operation, model });
      case "P2003":
        return new PrismaForeignKeyConstraintError({ cause: error, operation, model });
      case "P2004":
        return new PrismaDbConstraintError({ cause: error, operation, model });
      case "P2005":
      case "P2006":
      case "P2019":
        return new PrismaInputValidationError({ cause: error, operation, model });
      case "P2011":
      case "P2012":
        return new PrismaMissingRequiredValueError({ cause: error, operation, model });
      case "P2020":
        return new PrismaValueOutOfRangeError({ cause: error, operation, model });
      case "P2024":
        return new PrismaConnectionError({ cause: error, operation, model });
      case "P2034":
        return new PrismaTransactionConflictError({ cause: error, operation, model });
    }
  }
  throw error;
}

const clientOrTx = (client: PrismaClient) => Effect.map(
  Effect.serviceOption(PrismaTransactionClientService),
  Option.getOrElse(() => client),
);

export class PrismaService extends Service<PrismaService>()("PrismaService", {
  effect: Effect.gen(function* () {
    const client = yield* PrismaClientService;
    return {
      $transaction: <A, E, R>(
        effect: Effect.Effect<A, E, R>,
        options?: {
          maxWait?: number
          timeout?: number
          isolationLevel?: Prisma.TransactionIsolationLevel
        }
      ) =>
        Effect.gen(function* () {
          const runtime = yield* Effect.runtime<R>();
          const tx = yield* Effect.serviceOption(PrismaTransactionClientService);
          return yield* Option.match(tx, {
            onSome: (tx) => effect,
            onNone: () =>  Effect.tryPromise({
              try: () =>
                client.$transaction(async (tx) => {
                  const exit = await Runtime.runPromiseExit(runtime)(
                    effect.pipe(Effect.provideService(PrismaTransactionClientService, tx)) as Effect.Effect<A, E, R>,
                  )
                  if (Exit.isSuccess(exit)) {
                    return exit.value
                  }
                  throw Cause.squash(exit.cause)
                }, options),
              catch: (error) => error as E,
            }) as unknown as Effect.Effect<A, E, R>,
          })
        }),
      
    $executeRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$executeRaw(args[0], ...args.slice(1)) : client.$executeRaw(args)),
          catch: (error) => mapError(error, "$executeRaw", "Prisma")
        }),
      ),

    $executeRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => client.$executeRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$executeRawUnsafe", "Prisma")
        }),
      ),

    $queryRaw: (args: Prisma.Sql | [Prisma.Sql, ...any[]]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => (Array.isArray(args) ? client.$queryRaw(args[0], ...args.slice(1)) : client.$queryRaw(args)),
          catch: (error) => mapError(error, "$queryRaw", "Prisma")
        }),
      ),

    $queryRawUnsafe: (query: string, ...values: any[]) =>
      Effect.flatMap(clientOrTx(client), client =>
        Effect.tryPromise({
          try: () => client.$queryRawUnsafe(query, ...values),
          catch: (error) => mapError(error, "$queryRawUnsafe", "Prisma")
        }),
      ),

          googlePlaceUrlToScrape: {
      findUnique: <T extends Prisma.GooglePlaceUrlToScrapeFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "GooglePlaceUrlToScrape")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.GooglePlaceUrlToScrapeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "GooglePlaceUrlToScrape")
          }),
        ),

      findFirst: <T extends Prisma.GooglePlaceUrlToScrapeFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "GooglePlaceUrlToScrape")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.GooglePlaceUrlToScrapeFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "GooglePlaceUrlToScrape")
          }),
        ),

      findMany: <T extends Prisma.GooglePlaceUrlToScrapeFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "GooglePlaceUrlToScrape")
          }),
        ),

      create: <T extends Prisma.GooglePlaceUrlToScrapeCreateArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.create(args),
            catch: (error) => mapCreateError(error, "create", "GooglePlaceUrlToScrape")
          }),
        ),

      createMany: <T extends Prisma.GooglePlaceUrlToScrapeCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "GooglePlaceUrlToScrape")
          }),
        ),

      createManyAndReturn: <T extends Prisma.GooglePlaceUrlToScrapeCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "GooglePlaceUrlToScrape")
          }),
        ),

      delete: <T extends Prisma.GooglePlaceUrlToScrapeDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "GooglePlaceUrlToScrape")
          }),
        ),

      update: <T extends Prisma.GooglePlaceUrlToScrapeUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.update(args),
            catch: (error) => mapUpdateError(error, "update", "GooglePlaceUrlToScrape")
          }),
        ),

      deleteMany: <T extends Prisma.GooglePlaceUrlToScrapeDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "GooglePlaceUrlToScrape")
          }),
        ),

      updateMany: <T extends Prisma.GooglePlaceUrlToScrapeUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "GooglePlaceUrlToScrape")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.GooglePlaceUrlToScrapeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "GooglePlaceUrlToScrape")
          }),
        ),

      upsert: <T extends Prisma.GooglePlaceUrlToScrapeUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "GooglePlaceUrlToScrape")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.GooglePlaceUrlToScrapeCountArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.count(args),
            catch: (error) => mapFindError(error, "count", "GooglePlaceUrlToScrape")
          }),
        ),

      aggregate: <T extends Prisma.GooglePlaceUrlToScrapeAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.GooglePlaceUrlToScrapeAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "GooglePlaceUrlToScrape")
          }),
        ),

      groupBy: <
        T extends Prisma.GooglePlaceUrlToScrapeGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.GooglePlaceUrlToScrapeGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.GooglePlaceUrlToScrapeGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.GooglePlaceUrlToScrapeGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.googlePlaceUrlToScrape.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.GooglePlaceUrlToScrapeGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.GooglePlaceUrlToScrapeGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.GooglePlaceUrlToScrapeGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.GooglePlaceUrlToScrapeGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "GooglePlaceUrlToScrape")
          }),
        ),
    },

    placeEntry: {
      findUnique: <T extends Prisma.PlaceEntryFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "PlaceEntry")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.PlaceEntryFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "PlaceEntry")
          }),
        ),

      findFirst: <T extends Prisma.PlaceEntryFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "PlaceEntry")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.PlaceEntryFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "PlaceEntry")
          }),
        ),

      findMany: <T extends Prisma.PlaceEntryFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "PlaceEntry")
          }),
        ),

      create: <T extends Prisma.PlaceEntryCreateArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.create(args),
            catch: (error) => mapCreateError(error, "create", "PlaceEntry")
          }),
        ),

      createMany: <T extends Prisma.PlaceEntryCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "PlaceEntry")
          }),
        ),

      createManyAndReturn: <T extends Prisma.PlaceEntryCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "PlaceEntry")
          }),
        ),

      delete: <T extends Prisma.PlaceEntryDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "PlaceEntry")
          }),
        ),

      update: <T extends Prisma.PlaceEntryUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.update(args),
            catch: (error) => mapUpdateError(error, "update", "PlaceEntry")
          }),
        ),

      deleteMany: <T extends Prisma.PlaceEntryDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "PlaceEntry")
          }),
        ),

      updateMany: <T extends Prisma.PlaceEntryUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "PlaceEntry")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.PlaceEntryUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "PlaceEntry")
          }),
        ),

      upsert: <T extends Prisma.PlaceEntryUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "PlaceEntry")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.PlaceEntryCountArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.count(args),
            catch: (error) => mapFindError(error, "count", "PlaceEntry")
          }),
        ),

      aggregate: <T extends Prisma.PlaceEntryAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.PlaceEntryAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "PlaceEntry")
          }),
        ),

      groupBy: <
        T extends Prisma.PlaceEntryGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.PlaceEntryGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.PlaceEntryGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.PlaceEntryGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.placeEntry.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.PlaceEntryGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.PlaceEntryGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.PlaceEntryGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.PlaceEntryGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "PlaceEntry")
          }),
        ),
    },

    company: {
      findUnique: <T extends Prisma.CompanyFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "Company")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.CompanyFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "Company")
          }),
        ),

      findFirst: <T extends Prisma.CompanyFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "Company")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.CompanyFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "Company")
          }),
        ),

      findMany: <T extends Prisma.CompanyFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "Company")
          }),
        ),

      create: <T extends Prisma.CompanyCreateArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.create(args),
            catch: (error) => mapCreateError(error, "create", "Company")
          }),
        ),

      createMany: <T extends Prisma.CompanyCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "Company")
          }),
        ),

      createManyAndReturn: <T extends Prisma.CompanyCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "Company")
          }),
        ),

      delete: <T extends Prisma.CompanyDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "Company")
          }),
        ),

      update: <T extends Prisma.CompanyUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.update(args),
            catch: (error) => mapUpdateError(error, "update", "Company")
          }),
        ),

      deleteMany: <T extends Prisma.CompanyDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "Company")
          }),
        ),

      updateMany: <T extends Prisma.CompanyUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "Company")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.CompanyUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "Company")
          }),
        ),

      upsert: <T extends Prisma.CompanyUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "Company")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.CompanyCountArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.count(args),
            catch: (error) => mapFindError(error, "count", "Company")
          }),
        ),

      aggregate: <T extends Prisma.CompanyAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.CompanyAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "Company")
          }),
        ),

      groupBy: <
        T extends Prisma.CompanyGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.CompanyGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.CompanyGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.CompanyGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.company.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.CompanyGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.CompanyGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.CompanyGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.CompanyGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "Company")
          }),
        ),
    },

    firmService: {
      findUnique: <T extends Prisma.FirmServiceFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "FirmService")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.FirmServiceFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "FirmService")
          }),
        ),

      findFirst: <T extends Prisma.FirmServiceFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "FirmService")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.FirmServiceFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "FirmService")
          }),
        ),

      findMany: <T extends Prisma.FirmServiceFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "FirmService")
          }),
        ),

      create: <T extends Prisma.FirmServiceCreateArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.create(args),
            catch: (error) => mapCreateError(error, "create", "FirmService")
          }),
        ),

      createMany: <T extends Prisma.FirmServiceCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "FirmService")
          }),
        ),

      createManyAndReturn: <T extends Prisma.FirmServiceCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "FirmService")
          }),
        ),

      delete: <T extends Prisma.FirmServiceDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "FirmService")
          }),
        ),

      update: <T extends Prisma.FirmServiceUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.update(args),
            catch: (error) => mapUpdateError(error, "update", "FirmService")
          }),
        ),

      deleteMany: <T extends Prisma.FirmServiceDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "FirmService")
          }),
        ),

      updateMany: <T extends Prisma.FirmServiceUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "FirmService")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.FirmServiceUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "FirmService")
          }),
        ),

      upsert: <T extends Prisma.FirmServiceUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "FirmService")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.FirmServiceCountArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.count(args),
            catch: (error) => mapFindError(error, "count", "FirmService")
          }),
        ),

      aggregate: <T extends Prisma.FirmServiceAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.FirmServiceAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "FirmService")
          }),
        ),

      groupBy: <
        T extends Prisma.FirmServiceGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.FirmServiceGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.FirmServiceGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.FirmServiceGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.firmService.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.FirmServiceGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.FirmServiceGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.FirmServiceGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.FirmServiceGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "FirmService")
          }),
        ),
    },

    crmSyncEvent: {
      findUnique: <T extends Prisma.CrmSyncEventFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "CrmSyncEvent")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.CrmSyncEventFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "CrmSyncEvent")
          }),
        ),

      findFirst: <T extends Prisma.CrmSyncEventFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "CrmSyncEvent")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.CrmSyncEventFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "CrmSyncEvent")
          }),
        ),

      findMany: <T extends Prisma.CrmSyncEventFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "CrmSyncEvent")
          }),
        ),

      create: <T extends Prisma.CrmSyncEventCreateArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.create(args),
            catch: (error) => mapCreateError(error, "create", "CrmSyncEvent")
          }),
        ),

      createMany: <T extends Prisma.CrmSyncEventCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "CrmSyncEvent")
          }),
        ),

      createManyAndReturn: <T extends Prisma.CrmSyncEventCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "CrmSyncEvent")
          }),
        ),

      delete: <T extends Prisma.CrmSyncEventDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "CrmSyncEvent")
          }),
        ),

      update: <T extends Prisma.CrmSyncEventUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.update(args),
            catch: (error) => mapUpdateError(error, "update", "CrmSyncEvent")
          }),
        ),

      deleteMany: <T extends Prisma.CrmSyncEventDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "CrmSyncEvent")
          }),
        ),

      updateMany: <T extends Prisma.CrmSyncEventUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "CrmSyncEvent")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.CrmSyncEventUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "CrmSyncEvent")
          }),
        ),

      upsert: <T extends Prisma.CrmSyncEventUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "CrmSyncEvent")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.CrmSyncEventCountArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.count(args),
            catch: (error) => mapFindError(error, "count", "CrmSyncEvent")
          }),
        ),

      aggregate: <T extends Prisma.CrmSyncEventAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.CrmSyncEventAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "CrmSyncEvent")
          }),
        ),

      groupBy: <
        T extends Prisma.CrmSyncEventGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.CrmSyncEventGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.CrmSyncEventGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.CrmSyncEventGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.crmSyncEvent.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.CrmSyncEventGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.CrmSyncEventGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.CrmSyncEventGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.CrmSyncEventGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "CrmSyncEvent")
          }),
        ),
    },

    notification: {
      findUnique: <T extends Prisma.NotificationFindUniqueArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationFindUniqueArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.findUnique(args),
            catch: (error) => mapFindError(error, "findUnique", "Notification")
          }),
        ),

      findUniqueOrThrow: <T extends Prisma.NotificationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationFindUniqueOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.findUniqueOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findUniqueOrThrow", "Notification")
          }),
        ),

      findFirst: <T extends Prisma.NotificationFindFirstArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationFindFirstArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.findFirst(args),
            catch: (error) => mapFindError(error, "findFirst", "Notification")
          }),
        ),

      findFirstOrThrow: <T extends Prisma.NotificationFindFirstOrThrowArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationFindFirstOrThrowArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.findFirstOrThrow(args),
            catch: (error) => mapFindOrThrowError(error, "findFirstOrThrow", "Notification")
          }),
        ),

      findMany: <T extends Prisma.NotificationFindManyArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationFindManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.findMany(args),
            catch: (error) => mapFindError(error, "findMany", "Notification")
          }),
        ),

      create: <T extends Prisma.NotificationCreateArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationCreateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.create(args),
            catch: (error) => mapCreateError(error, "create", "Notification")
          }),
        ),

      createMany: <T extends Prisma.NotificationCreateManyArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationCreateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.createMany(args),
            catch: (error) => mapCreateError(error, "createMany", "Notification")
          }),
        ),

      createManyAndReturn: <T extends Prisma.NotificationCreateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationCreateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.createManyAndReturn(args),
            catch: (error) => mapCreateError(error, "createManyAndReturn", "Notification")
          }),
        ),

      delete: <T extends Prisma.NotificationDeleteArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationDeleteArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.delete(args),
            catch: (error) => mapDeleteError(error, "delete", "Notification")
          }),
        ),

      update: <T extends Prisma.NotificationUpdateArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationUpdateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.update(args),
            catch: (error) => mapUpdateError(error, "update", "Notification")
          }),
        ),

      deleteMany: <T extends Prisma.NotificationDeleteManyArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationDeleteManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.deleteMany(args),
            catch: (error) => mapDeleteManyError(error, "deleteMany", "Notification")
          }),
        ),

      updateMany: <T extends Prisma.NotificationUpdateManyArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationUpdateManyArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.updateMany(args),
            catch: (error) => mapUpdateManyError(error, "updateMany", "Notification")
          }),
        ),

      updateManyAndReturn: <T extends Prisma.NotificationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationUpdateManyAndReturnArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.updateManyAndReturn(args),
            catch: (error) => mapUpdateManyError(error, "updateManyAndReturn", "Notification")
          }),
        ),

      upsert: <T extends Prisma.NotificationUpsertArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationUpsertArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.upsert(args),
            catch: (error) => mapCreateError(error, "upsert", "Notification")
          }),
        ),

      // Aggregation operations
      count: <T extends Prisma.NotificationCountArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationCountArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.count(args),
            catch: (error) => mapFindError(error, "count", "Notification")
          }),
        ),

      aggregate: <T extends Prisma.NotificationAggregateArgs>(args: Prisma.SelectSubset<T, Prisma.NotificationAggregateArgs>) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.aggregate(args),
            catch: (error) => mapFindError(error, "aggregate", "Notification")
          }),
        ),

      groupBy: <
        T extends Prisma.NotificationGroupByArgs,
        HasSelectOrTake extends Prisma.Or<
          Prisma.Extends<'skip', Prisma.Keys<T>>,
          Prisma.Extends<'take', Prisma.Keys<T>>
        >,
        OrderByArg extends Prisma.True extends HasSelectOrTake
          ? { orderBy: Prisma.NotificationGroupByArgs['orderBy'] }
          : { orderBy?: Prisma.NotificationGroupByArgs['orderBy'] },
        OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
        ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
        ByValid extends Prisma.Has<ByFields, OrderFields>,
        HavingFields extends Prisma.GetHavingFields<T['having']>,
        HavingValid extends Prisma.Has<ByFields, HavingFields>,
        ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
        InputErrors extends ByEmpty extends Prisma.True
        ? `Error: "by" must not be empty.`
        : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
              ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
              : [
                  Error,
                  'Field ',
                  P,
                  ` in "having" needs to be provided in "by"`,
                ]
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "take", you also need to provide "orderBy"'
        : 'skip' extends Prisma.Keys<T>
        ? 'orderBy' extends Prisma.Keys<T>
          ? ByValid extends Prisma.True
            ? {}
            : {
                [P in OrderFields]: P extends ByFields
                  ? never
                  : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
              }[OrderFields]
          : 'Error: If you provide "skip", you also need to provide "orderBy"'
        : ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      >(args: Prisma.SubsetIntersection<T, Prisma.NotificationGroupByArgs, OrderByArg> & InputErrors) =>
        Effect.flatMap(clientOrTx(client), client =>
          Effect.tryPromise({
            try: () => client.notification.groupBy(args as any) as Prisma.PrismaPromise<
              Array<Prisma.PickEnumerable<Prisma.NotificationGroupByOutputType, T["by"]> & {
                  [P in keyof T &
                    keyof Prisma.NotificationGroupByOutputType]: P extends "_count"
                    ? T[P] extends boolean
                      ? number
                      : Prisma.GetScalarType<
                          T[P],
                          Prisma.NotificationGroupByOutputType[P]
                        >
                    : Prisma.GetScalarType<
                        T[P],
                        Prisma.NotificationGroupByOutputType[P]
                      >;
                }>>,
            catch: (error) => mapFindError(error, "groupBy", "Notification")
          }),
        ),
    }
    }
  })
}) {}
